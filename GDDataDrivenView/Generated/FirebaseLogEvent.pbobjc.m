// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: firebase_log_event.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "FirebaseLogEvent.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - FIRFirebaseLogEventRoot

@implementation FIRFirebaseLogEventRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - FIRFirebaseLogEventRoot_FileDescriptor

static GPBFileDescriptor *FIRFirebaseLogEventRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.firebase"
                                                 objcPrefix:@"FIR"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum FIRLogEvents

GPBEnumDescriptor *FIRLogEvents_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "LogEventNameUnset\000SelectContent\000Share\000Sp"
        "endVirtualCurrency\000SignUp\000Search\000Present"
        "Offer\000JoinGroup\000TutorialBegin\000TutorialCo"
        "mplete\000AddPaymentInfo\000ViewItem\000ViewItemL"
        "ist\000ViewSearchResults\000EcommercePurchase\000"
        "PurchaseRefund\000AddToCart\000BeginCheckout\000A"
        "ddToWishlist\000GenerateLead\000LevelUp\000PostSc"
        "ore\000UnlockAchievement\000";
    static const int32_t values[] = {
        FIRLogEvents_LogEventNameUnset,
        FIRLogEvents_SelectContent,
        FIRLogEvents_Share,
        FIRLogEvents_SpendVirtualCurrency,
        FIRLogEvents_SignUp,
        FIRLogEvents_Search,
        FIRLogEvents_PresentOffer,
        FIRLogEvents_JoinGroup,
        FIRLogEvents_TutorialBegin,
        FIRLogEvents_TutorialComplete,
        FIRLogEvents_AddPaymentInfo,
        FIRLogEvents_ViewItem,
        FIRLogEvents_ViewItemList,
        FIRLogEvents_ViewSearchResults,
        FIRLogEvents_EcommercePurchase,
        FIRLogEvents_PurchaseRefund,
        FIRLogEvents_AddToCart,
        FIRLogEvents_BeginCheckout,
        FIRLogEvents_AddToWishlist,
        FIRLogEvents_GenerateLead,
        FIRLogEvents_LevelUp,
        FIRLogEvents_PostScore,
        FIRLogEvents_UnlockAchievement,
    };
    static const char *extraTextFormatInfo = "\026\001&\247\000\002%\000\003%\247\250\000\004$\242\000\005&\000\006\'\245\000\007$\245\000\010(\245\000\t(\250\000\n#\247\244\000\013$\244\000\014$\244\244\000\r$\246\247\000\016)\250\000\017(\246\000\020#\242\244\000\021%\250\000\022#\242\250\000\023(\244\000\024%\242\000\025$\245\000\026&\253\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FIRLogEvents)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FIRLogEvents_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FIRLogEvents_IsValidValue(int32_t value__) {
  switch (value__) {
    case FIRLogEvents_LogEventNameUnset:
    case FIRLogEvents_SelectContent:
    case FIRLogEvents_Share:
    case FIRLogEvents_SpendVirtualCurrency:
    case FIRLogEvents_SignUp:
    case FIRLogEvents_Search:
    case FIRLogEvents_PresentOffer:
    case FIRLogEvents_JoinGroup:
    case FIRLogEvents_TutorialBegin:
    case FIRLogEvents_TutorialComplete:
    case FIRLogEvents_AddPaymentInfo:
    case FIRLogEvents_ViewItem:
    case FIRLogEvents_ViewItemList:
    case FIRLogEvents_ViewSearchResults:
    case FIRLogEvents_EcommercePurchase:
    case FIRLogEvents_PurchaseRefund:
    case FIRLogEvents_AddToCart:
    case FIRLogEvents_BeginCheckout:
    case FIRLogEvents_AddToWishlist:
    case FIRLogEvents_GenerateLead:
    case FIRLogEvents_LevelUp:
    case FIRLogEvents_PostScore:
    case FIRLogEvents_UnlockAchievement:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - FIRSelectContentEvent

@implementation FIRSelectContentEvent

@dynamic contentType;
@dynamic itemId;

typedef struct FIRSelectContentEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *contentType;
  NSString *itemId;
} FIRSelectContentEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentType",
        .dataTypeSpecific.className = NULL,
        .number = FIRSelectContentEvent_FieldNumber_ContentType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRSelectContentEvent__storage_, contentType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.className = NULL,
        .number = FIRSelectContentEvent_FieldNumber_ItemId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRSelectContentEvent__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRSelectContentEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRSelectContentEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRShareEvent

@implementation FIRShareEvent

@dynamic contentType;
@dynamic itemId;

typedef struct FIRShareEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *contentType;
  NSString *itemId;
} FIRShareEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentType",
        .dataTypeSpecific.className = NULL,
        .number = FIRShareEvent_FieldNumber_ContentType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRShareEvent__storage_, contentType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.className = NULL,
        .number = FIRShareEvent_FieldNumber_ItemId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRShareEvent__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRShareEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRShareEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRSpendVirtualCurrencyEvent

@implementation FIRSpendVirtualCurrencyEvent

@dynamic itemName;
@dynamic virtualCurrencyName;
@dynamic value;

typedef struct FIRSpendVirtualCurrencyEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
  NSString *itemName;
  NSString *virtualCurrencyName;
} FIRSpendVirtualCurrencyEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemName",
        .dataTypeSpecific.className = NULL,
        .number = FIRSpendVirtualCurrencyEvent_FieldNumber_ItemName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRSpendVirtualCurrencyEvent__storage_, itemName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "virtualCurrencyName",
        .dataTypeSpecific.className = NULL,
        .number = FIRSpendVirtualCurrencyEvent_FieldNumber_VirtualCurrencyName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRSpendVirtualCurrencyEvent__storage_, virtualCurrencyName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FIRSpendVirtualCurrencyEvent_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRSpendVirtualCurrencyEvent__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRSpendVirtualCurrencyEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRSpendVirtualCurrencyEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRSignUpEvent

@implementation FIRSignUpEvent

@dynamic method;

typedef struct FIRSignUpEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *method;
} FIRSignUpEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "method",
        .dataTypeSpecific.className = NULL,
        .number = FIRSignUpEvent_FieldNumber_Method,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRSignUpEvent__storage_, method),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRSignUpEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRSignUpEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRSearchEvent

@implementation FIRSearchEvent

@dynamic searchTerm;
@dynamic startDate;
@dynamic endDate;
@dynamic origin;
@dynamic destination;

typedef struct FIRSearchEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *searchTerm;
  NSString *startDate;
  NSString *endDate;
  NSString *origin;
  NSString *destination;
} FIRSearchEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchTerm",
        .dataTypeSpecific.className = NULL,
        .number = FIRSearchEvent_FieldNumber_SearchTerm,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRSearchEvent__storage_, searchTerm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startDate",
        .dataTypeSpecific.className = NULL,
        .number = FIRSearchEvent_FieldNumber_StartDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRSearchEvent__storage_, startDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endDate",
        .dataTypeSpecific.className = NULL,
        .number = FIRSearchEvent_FieldNumber_EndDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRSearchEvent__storage_, endDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "origin",
        .dataTypeSpecific.className = NULL,
        .number = FIRSearchEvent_FieldNumber_Origin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FIRSearchEvent__storage_, origin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "destination",
        .dataTypeSpecific.className = NULL,
        .number = FIRSearchEvent_FieldNumber_Destination,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FIRSearchEvent__storage_, destination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRSearchEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRSearchEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRPresentOfferEvent

@implementation FIRPresentOfferEvent

@dynamic itemId;
@dynamic itemName;
@dynamic itemCategory;

typedef struct FIRPresentOfferEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *itemId;
  NSString *itemName;
  NSString *itemCategory;
} FIRPresentOfferEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.className = NULL,
        .number = FIRPresentOfferEvent_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRPresentOfferEvent__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemName",
        .dataTypeSpecific.className = NULL,
        .number = FIRPresentOfferEvent_FieldNumber_ItemName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRPresentOfferEvent__storage_, itemName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemCategory",
        .dataTypeSpecific.className = NULL,
        .number = FIRPresentOfferEvent_FieldNumber_ItemCategory,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRPresentOfferEvent__storage_, itemCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRPresentOfferEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRPresentOfferEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRJoinGroupEvent

@implementation FIRJoinGroupEvent

@dynamic groupId;

typedef struct FIRJoinGroupEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
} FIRJoinGroupEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = FIRJoinGroupEvent_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRJoinGroupEvent__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRJoinGroupEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRJoinGroupEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRViewItemEvent

@implementation FIRViewItemEvent

@dynamic itemId;
@dynamic itemLocationId;
@dynamic contentType;
@dynamic itemName;
@dynamic itemCategory;
@dynamic currency;
@dynamic value;
@dynamic searchTerm;
@dynamic startDate;
@dynamic endDate;

typedef struct FIRViewItemEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *itemId;
  NSString *itemLocationId;
  NSString *contentType;
  NSString *itemName;
  NSString *itemCategory;
  NSString *currency;
  NSString *value;
  NSString *searchTerm;
  NSString *startDate;
  NSString *endDate;
} FIRViewItemEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemLocationId",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_ItemLocationId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, itemLocationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentType",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_ContentType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, contentType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemName",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_ItemName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, itemName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemCategory",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_ItemCategory,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, itemCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_Currency,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_Value,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "searchTerm",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_SearchTerm,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, searchTerm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startDate",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_StartDate,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, startDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endDate",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemEvent_FieldNumber_EndDate,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(FIRViewItemEvent__storage_, endDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRViewItemEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRViewItemEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRViewItemListEvent

@implementation FIRViewItemListEvent

@dynamic itemCategory;
@dynamic startDate;
@dynamic endDate;

typedef struct FIRViewItemListEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *itemCategory;
  NSString *startDate;
  NSString *endDate;
} FIRViewItemListEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemCategory",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemListEvent_FieldNumber_ItemCategory,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRViewItemListEvent__storage_, itemCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startDate",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemListEvent_FieldNumber_StartDate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRViewItemListEvent__storage_, startDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endDate",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewItemListEvent_FieldNumber_EndDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRViewItemListEvent__storage_, endDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRViewItemListEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRViewItemListEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRViewSearchResultsEvent

@implementation FIRViewSearchResultsEvent

@dynamic searchTerm;

typedef struct FIRViewSearchResultsEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *searchTerm;
} FIRViewSearchResultsEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchTerm",
        .dataTypeSpecific.className = NULL,
        .number = FIRViewSearchResultsEvent_FieldNumber_SearchTerm,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRViewSearchResultsEvent__storage_, searchTerm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRViewSearchResultsEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRViewSearchResultsEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIREcommercePurchaseEvent

@implementation FIREcommercePurchaseEvent

@dynamic coupon;
@dynamic currency;
@dynamic value;
@dynamic tax;
@dynamic shipping;
@dynamic transactionId;
@dynamic quantity;
@dynamic location;
@dynamic startDate;
@dynamic endDate;
@dynamic origin;
@dynamic destination;

typedef struct FIREcommercePurchaseEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
  int32_t quantity;
  NSString *coupon;
  NSString *currency;
  NSString *tax;
  NSString *shipping;
  NSString *transactionId;
  NSString *location;
  NSString *startDate;
  NSString *endDate;
  NSString *origin;
  NSString *destination;
} FIREcommercePurchaseEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "coupon",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_Coupon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, coupon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_Currency,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tax",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_Tax,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, tax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shipping",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_Shipping,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, shipping),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transactionId",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_TransactionId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, transactionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quantity",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_Quantity,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, quantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_Location,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startDate",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_StartDate,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, startDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endDate",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_EndDate,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, endDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "origin",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_Origin,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, origin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "destination",
        .dataTypeSpecific.className = NULL,
        .number = FIREcommercePurchaseEvent_FieldNumber_Destination,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(FIREcommercePurchaseEvent__storage_, destination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIREcommercePurchaseEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIREcommercePurchaseEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRPurchaseRefundEvent

@implementation FIRPurchaseRefundEvent

@dynamic quantity;
@dynamic value;
@dynamic currency;
@dynamic transactionId;

typedef struct FIRPurchaseRefundEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t quantity;
  int32_t value;
  NSString *currency;
  NSString *transactionId;
} FIRPurchaseRefundEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "quantity",
        .dataTypeSpecific.className = NULL,
        .number = FIRPurchaseRefundEvent_FieldNumber_Quantity,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRPurchaseRefundEvent__storage_, quantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FIRPurchaseRefundEvent_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRPurchaseRefundEvent__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = FIRPurchaseRefundEvent_FieldNumber_Currency,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRPurchaseRefundEvent__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transactionId",
        .dataTypeSpecific.className = NULL,
        .number = FIRPurchaseRefundEvent_FieldNumber_TransactionId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FIRPurchaseRefundEvent__storage_, transactionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRPurchaseRefundEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRPurchaseRefundEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRAddToCartEvent

@implementation FIRAddToCartEvent

@dynamic quantity;
@dynamic itemCategory;
@dynamic itemName;
@dynamic itemId;
@dynamic itemLocationId;
@dynamic value;
@dynamic price;
@dynamic currency;

typedef struct FIRAddToCartEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t quantity;
  int32_t value;
  int32_t price;
  NSString *itemCategory;
  NSString *itemName;
  NSString *itemId;
  NSString *itemLocationId;
  NSString *currency;
} FIRAddToCartEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "quantity",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToCartEvent_FieldNumber_Quantity,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRAddToCartEvent__storage_, quantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "itemCategory",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToCartEvent_FieldNumber_ItemCategory,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRAddToCartEvent__storage_, itemCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemName",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToCartEvent_FieldNumber_ItemName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRAddToCartEvent__storage_, itemName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToCartEvent_FieldNumber_ItemId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FIRAddToCartEvent__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemLocationId",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToCartEvent_FieldNumber_ItemLocationId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FIRAddToCartEvent__storage_, itemLocationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToCartEvent_FieldNumber_Value,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FIRAddToCartEvent__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToCartEvent_FieldNumber_Price,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FIRAddToCartEvent__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToCartEvent_FieldNumber_Currency,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FIRAddToCartEvent__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRAddToCartEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRAddToCartEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRBeginCheckoutEvent

@implementation FIRBeginCheckoutEvent

@dynamic coupon;
@dynamic currency;
@dynamic value;

typedef struct FIRBeginCheckoutEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
  NSString *coupon;
  NSString *currency;
} FIRBeginCheckoutEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "coupon",
        .dataTypeSpecific.className = NULL,
        .number = FIRBeginCheckoutEvent_FieldNumber_Coupon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRBeginCheckoutEvent__storage_, coupon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = FIRBeginCheckoutEvent_FieldNumber_Currency,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRBeginCheckoutEvent__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FIRBeginCheckoutEvent_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRBeginCheckoutEvent__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRBeginCheckoutEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRBeginCheckoutEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRAddToWishlistEvent

@implementation FIRAddToWishlistEvent

@dynamic quantity;
@dynamic itemCategory;
@dynamic itemName;
@dynamic itemId;
@dynamic itemLocationId;
@dynamic value;
@dynamic price;
@dynamic currency;

typedef struct FIRAddToWishlistEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t quantity;
  int32_t value;
  int32_t price;
  NSString *itemCategory;
  NSString *itemName;
  NSString *itemId;
  NSString *itemLocationId;
  NSString *currency;
} FIRAddToWishlistEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "quantity",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToWishlistEvent_FieldNumber_Quantity,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRAddToWishlistEvent__storage_, quantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "itemCategory",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToWishlistEvent_FieldNumber_ItemCategory,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRAddToWishlistEvent__storage_, itemCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemName",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToWishlistEvent_FieldNumber_ItemName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRAddToWishlistEvent__storage_, itemName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToWishlistEvent_FieldNumber_ItemId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FIRAddToWishlistEvent__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemLocationId",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToWishlistEvent_FieldNumber_ItemLocationId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FIRAddToWishlistEvent__storage_, itemLocationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToWishlistEvent_FieldNumber_Value,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FIRAddToWishlistEvent__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToWishlistEvent_FieldNumber_Price,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FIRAddToWishlistEvent__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = FIRAddToWishlistEvent_FieldNumber_Currency,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FIRAddToWishlistEvent__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRAddToWishlistEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRAddToWishlistEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRGenerateLeadEvent

@implementation FIRGenerateLeadEvent

@dynamic value;
@dynamic currency;

typedef struct FIRGenerateLeadEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
  NSString *currency;
} FIRGenerateLeadEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FIRGenerateLeadEvent_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRGenerateLeadEvent__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = FIRGenerateLeadEvent_FieldNumber_Currency,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRGenerateLeadEvent__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRGenerateLeadEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRGenerateLeadEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRLevelUpEvent

@implementation FIRLevelUpEvent

@dynamic character;
@dynamic level;

typedef struct FIRLevelUpEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
  NSString *character;
} FIRLevelUpEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "character",
        .dataTypeSpecific.className = NULL,
        .number = FIRLevelUpEvent_FieldNumber_Character,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRLevelUpEvent__storage_, character),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = FIRLevelUpEvent_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRLevelUpEvent__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRLevelUpEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRLevelUpEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRPostScoreEvent

@implementation FIRPostScoreEvent

@dynamic character;
@dynamic level;
@dynamic score;

typedef struct FIRPostScoreEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
  int32_t score;
  NSString *character;
} FIRPostScoreEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "character",
        .dataTypeSpecific.className = NULL,
        .number = FIRPostScoreEvent_FieldNumber_Character,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRPostScoreEvent__storage_, character),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = FIRPostScoreEvent_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FIRPostScoreEvent__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = FIRPostScoreEvent_FieldNumber_Score,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FIRPostScoreEvent__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRPostScoreEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRPostScoreEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FIRUnlockAchievementEvent

@implementation FIRUnlockAchievementEvent

@dynamic achievementId;

typedef struct FIRUnlockAchievementEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *achievementId;
} FIRUnlockAchievementEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "achievementId",
        .dataTypeSpecific.className = NULL,
        .number = FIRUnlockAchievementEvent_FieldNumber_AchievementId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FIRUnlockAchievementEvent__storage_, achievementId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FIRUnlockAchievementEvent class]
                                     rootClass:[FIRFirebaseLogEventRoot class]
                                          file:FIRFirebaseLogEventRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FIRUnlockAchievementEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
